name: Build Docker-ready kernel (SM8250/lmi) - v3.7.2

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: "Kernel repo URL"
        required: false
        default: "https://github.com/liyafe1997/kernel_xiaomi_sm8250_mod"
      branch:
        description: "Kernel branch"
        required: true
        default: "android15-lineage22-mod"
      device:
        description: "Device codename"
        required: true
        default: "lmi"
      enable_docker_configs:
        description: "Force-enable Docker-required CONFIG_*"
        required: true
        default: "true"
      ak3_kernel_string:
        description: "AnyKernel3 display string"
        required: false
        default: "Docker-ready SM8250 kernel for lmi (crDroid)"
      ak3_supported_versions:
        description: "ROM Android versions (list or range)"
        required: false
        default: "14, 15"
      release_tag:
        description: "Release tag (auto if empty)"
        required: false
        default: ""

permissions:
  contents: write

concurrency:
  group: docker-kernel-lmi-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      ARCH: arm64
      SUBARCH: arm64
      OUT: out
      CC: clang
      LD: ld.lld
      LLVM: -15
      KBUILD_BUILD_USER: "gh-actions"
      KBUILD_BUILD_HOST: "ubuntu"
      TZ: "Asia/Shanghai"

    steps:
      - name: Checkout kit repo (to load workflow)
        uses: actions/checkout@v4

      - name: Clone kernel source
        shell: bash
        run: |
          set -e
          git clone --depth=1 -b "${{ inputs.branch }}" "${{ inputs.repo_url }}" kernel_src
          cd kernel_src
          git rev-parse --short HEAD

      - name: Install build deps (clang/llvm/binutils)
        shell: bash
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y \
            bc bison flex libssl-dev libelf-dev dwarves git curl wget zip unzip \
            python3 python3-pip build-essential \
            clang-15 llvm-15 lld-15 llvm-15-tools \
            binutils-aarch64-linux-gnu gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
          sudo ln -sf /usr/bin/clang-15 /usr/bin/clang
          sudo ln -sf /usr/bin/ld.lld-15 /usr/bin/ld.lld
          sudo ln -sf /usr/bin/llvm-objdump-15 /usr/bin/llvm-objdump
          sudo ln -sf /usr/bin/llvm-objcopy-15 /usr/bin/llvm-objcopy
          sudo ln -sf /usr/bin/llvm-ar-15 /usr/bin/llvm-ar
          sudo ln -sf /usr/bin/llvm-nm-15 /usr/bin/llvm-nm

      - name: Verify LLVM toolchain presence
        shell: bash
        run: |
          set -e
          for t in clang-15 ld.lld-15 llvm-objdump-15 llvm-objcopy-15 llvm-ar-15 llvm-nm-15; do
            which "$t" && "$t" --version || true
          done
          for t in clang ld.lld llvm-objdump llvm-objcopy llvm-ar llvm-nm; do
            which "$t" && "$t" --version || true
          done

      - name: Prepare .config from defconfig (lmi_defconfig)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          mkdir -p "${OUT}"
          export ARCH=arm64
          export SUBARCH=arm64
          export CC=clang
          export LD=ld.lld
          export CROSS_COMPILE=aarch64-linux-gnu-
          export CLANG_TRIPLE=aarch64-linux-gnu-
          make LLVM="${LLVM}" O="${OUT}" ARCH="${ARCH}" lmi_defconfig
          make LLVM="${LLVM}" O="${OUT}" ARCH="${ARCH}" scripts

      - name: Apply xt_qtaguid patch (auto-detect path; non-fatal)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          PATCH_URL="https://raw.githubusercontent.com/DogDayAndroid/Android-Builder/refs/heads/main/Kernel/LXC/Patches/xt_qtaguid.patch"
          echo "[INFO] Fetching: ${PATCH_URL}"
          curl -L -o /tmp/xt_qtaguid.patch "${PATCH_URL}"
          TARGET_FILE=""
          for cand in \
            net/netfilter/xt_qtaguid.c \
            kernel/net/netfilter/xt_qtaguid.c \
            net/netfilter/xt_qtaguid/xt_qtaguid.c \
            kernel/net/netfilter/xt_qtaguid/xt_qtaguid.c ; do
            if [ -f "${cand}" ]; then TARGET_FILE="${cand}"; break; fi
          done
          if [ -z "${TARGET_FILE}" ]; then
            echo "[WARN] xt_qtaguid source not found; skip patch."
            exit 0
          fi
          echo "[INFO] Found xt_qtaguid at: ${TARGET_FILE}"
          if ! git apply --reject --verbose /tmp/xt_qtaguid.patch; then
            echo "[WARN] git apply failed, try patch -p0/-p1 (non-fatal)"
            patch -p0 < /tmp/xt_qtaguid.patch || true
            patch -p1 < /tmp/xt_qtaguid.patch || true
            echo "[WARN] xt_qtaguid patch may have failed; continue"
          fi
          
      - name: Force-enable Docker-required CONFIGs (extended)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          export ARCH=arm64 SUBARCH=arm64
          export CC=clang LD=ld.lld
          export CROSS_COMPILE=aarch64-linux-gnu- CLANG_TRIPLE=aarch64-linux-gnu-

          CFG="${OUT}/.config"
          SC="./scripts/config"

          enable_y() { "${SC}" --file "${CFG}" --enable "$1" || true; }
          enable_m() { "${SC}" --file "${CFG}" --module "$1" || true; }
          set_str() { "${SC}" --file "${CFG}" --set-str "$1" "$2" || true; }

          # 基础：可读出内核配置/本地版本标识
          enable_y CONFIG_IKCONFIG
          enable_y CONFIG_IKCONFIG_PROC
          set_str CONFIG_LOCALVERSION "-docker-ready"

          # Namespaces / Cgroups 基础（Docker必需）
          enable_y CONFIG_NAMESPACES
          enable_y CONFIG_CGROUPS
          enable_y CONFIG_CGROUP_SCHED
          enable_y CONFIG_CGROUP_FREEZER
          enable_y CONFIG_CGROUP_CPUACCT
          enable_y CONFIG_CPUSETS
          enable_y CONFIG_MEMCG

          # 你设备当前缺失的项（强制开启）
          enable_y CONFIG_CGROUP_PIDS
          enable_y CONFIG_CGROUP_DEVICE

          # OverlayFS 作为存储驱动
          enable_y CONFIG_OVERLAY_FS

          # 虚拟网卡 + 桥接
          enable_y CONFIG_VETH
          enable_y CONFIG_BRIDGE
          # 关键：桥接进入 Netfilter（Docker bridge/NAT）
          enable_y CONFIG_BRIDGE_NETFILTER

          # Netfilter 基础/xtables
          enable_y CONFIG_NETFILTER
          enable_y CONFIG_NETFILTER_ADVANCED
          enable_y CONFIG_NETFILTER_XTABLES
          enable_y CONFIG_NF_CONNTRACK
          enable_y CONFIG_NF_NAT
          enable_y CONFIG_IP_NF_IPTABLES
          enable_y CONFIG_IP_NF_FILTER
          enable_y CONFIG_IP_NF_MANGLE

          # NAT/MASQUERADE（Docker 默认依赖）
          enable_y CONFIG_NETFILTER_XT_NAT
          enable_y CONFIG_IP_NF_TARGET_MASQUERADE
          enable_y CONFIG_NF_NAT_MASQUERADE_IPV4
          enable_y CONFIG_NF_NAT_MASQUERADE_IPV6

          # 常用匹配（addrtype / conntrack / state / statistic）
          enable_y CONFIG_NETFILTER_XT_MATCH_ADDRTYPE
          enable_y CONFIG_NETFILTER_XT_MATCH_CONNTRACK
          enable_y CONFIG_NETFILTER_XT_MATCH_STATE
          enable_y CONFIG_NETFILTER_XT_MATCH_STATISTIC

          # 其它常见匹配/目标可按需开启（已有则忽略）
          enable_y CONFIG_NETFILTER_XT_TARGET_REDIRECT
          enable_y CONFIG_NETFILTER_XT_TARGET_TCPMSS
          enable_y CONFIG_NETFILTER_XT_TARGET_TPROXY

          # 固化为最终配置
          make LLVM="${LLVM}" O="${OUT}" ARCH="${ARCH}" olddefconfig

          echo "[INFO] Summary of Docker-critical flags:"
          zgrep -E 'CONFIG_(NAMESPACES|CGROUP|OVERLAY|VETH|BRIDGE|BRIDGE_NETFILTER|NETFILTER|XTABLES|NF_CONNTRACK|NF_NAT|IP_NF|MASQUERADE|ADDRTYPE|CONNTRACK|STATE|STATISTIC)=' "${CFG}" | sort || true

      - name: Validate container compatibility (Moby check-config.sh)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          wget -O /tmp/check-config.sh https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh
          chmod +x /tmp/check-config.sh
          /tmp/check-config.sh "${OUT}/.config" || true

      - name: Build kernel (Image.gz / Image.gz-dtb)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          export ARCH=arm64
          export SUBARCH=arm64
          export CC=clang
          export LD=ld.lld
          export CROSS_COMPILE=aarch64-linux-gnu-
          export CLANG_TRIPLE=aarch64-linux-gnu-
          make LLVM="${LLVM}" O="${OUT}" -j"$(nproc)"
          ls -la "${OUT}/arch/arm64/boot" || true

      - name: Write local Docker kernel validator
        shell: bash
        working-directory: kernel_src
        run: |
          cat > .ci/check_docker_kernel.sh <<'SH'
          #!/usr/bin/env bash
          set -euo pipefail
          CFG="${1:-out/.config}"

          req_flags=(  # 必需项（缺失则失败）
            NAMESPACES
            CGROUPS
            CGROUP_SCHED
            CGROUP_FREEZER
            CGROUP_CPUACCT
            CPUSETS
            MEMCG
            CGROUP_PIDS
            CGROUP_DEVICE
            OVERLAY_FS
            VETH
            BRIDGE
            BRIDGE_NETFILTER
            NETFILTER
            NETFILTER_ADVANCED
            NETFILTER_XTABLES
            NF_CONNTRACK
            NF_NAT
            IP_NF_IPTABLES
            IP_NF_FILTER
            IP_NF_MANGLE
            NETFILTER_XT_NAT
            IP_NF_TARGET_MASQUERADE
            NF_NAT_MASQUERADE_IPV4
            NETFILTER_XT_MATCH_ADDRTYPE
            NETFILTER_XT_MATCH_CONNTRACK
            NETFILTER_XT_MATCH_STATE
            NETFILTER_XT_MATCH_STATISTIC
          )

          opt_flags=(  # 可选项（建议开启）
            NF_NAT_MASQUERADE_IPV6
            NETFILTER_XT_TARGET_REDIRECT
            NETFILTER_XT_TARGET_TCPMSS
            NETFILTER_XT_TARGET_TPROXY
          )

          report="docker-kernel-check.txt"
          : > "$report"

          echo "Kernel CONFIG check for Docker @ $(date)" >> "$report"
          echo "Config file: $CFG" >> "$report"
          echo >> "$report"

          missing=0
          echo "== Generally Necessary ==" >> "$report"
          for f in "${req_flags[@]}"; do
            if zgrep -q "CONFIG_${f}=[ym]" "$CFG"; then
              printf "  - CONFIG_%s: OK\n" "$f" >> "$report"
            else
              printf "  - CONFIG_%s: MISSING\n" "$f" >> "$report"
              missing=$((missing+1))
            fi
          done

          echo >> "$report"
          echo "== Optional / Recommended ==" >> "$report"
          for f in "${opt_flags[@]}"; do
            if zgrep -q "CONFIG_${f}=[ym]" "$CFG"; then
              printf "  - CONFIG_%s: OK\n" "$f" >> "$report"
            else
              printf "  - CONFIG_%s: (optional) missing\n" "$f" >> "$report"
            fi
          done

          echo >> "$report"
          echo "Missing count (required): $missing" >> "$report"

          # 缺关键项则失败
          if [ "$missing" -gt 0 ]; then
            echo "[ERROR] Required kernel flags missing: $missing"
            exit 2
          fi
          SH
          chmod +x .ci/check_docker_kernel.sh

      - name: Validate Docker kernel flags (local)
        shell: bash
        working-directory: kernel_src
        run: |
          set -e
          .ci/check_docker_kernel.sh "${OUT}/.config"
          echo "[INFO] Validation PASSED"

      - name: Upload Docker kernel validation report
        uses: actions/upload-artifact@v4
        with:
          name: docker-kernel-check
          path: kernel_src/docker-kernel-check.txt



      - name: Pack AnyKernel3 zip
        shell: bash
        run: |
          set -euo pipefail
          git clone --depth=1 https://github.com/osm0sis/AnyKernel3 ak3
          cd ak3

          # 修改 anykernel.sh 基本兼容性
          sed -i 's/do.devicecheck=1/do.devicecheck=0/g' anykernel.sh
          sed -i 's!BLOCK=/dev/block/platform/omap/omap_hsmmc.0/by-name/boot;!BLOCK=auto;!g' anykernel.sh
          sed -i 's/is_slot_device=0;/is_slot_device=auto;/g' anykernel.sh

          SRC="../kernel_src/${OUT}/arch/${ARCH}/boot"
          mkdir -p kernel

          # 优先级：Image.gz-dtb > Image.gz > Image（压缩）
          if [ -f "${SRC}/Image.gz-dtb" ]; then
            cp "${SRC}/Image.gz-dtb" kernel/
          elif [ -f "${SRC}/Image.gz" ]; then
            cp "${SRC}/Image.gz" kernel/
          elif [ -f "${SRC}/Image" ]; then
            echo "[INFO] Only Image found; compressing to Image.gz"
            gzip -c9 "${SRC}/Image" > kernel/Image.gz
          else
            echo "[ERROR] No kernel image found!" && ls -la "${SRC}" && exit 1
          fi

          # 可选附带 dtbo.img / dtb
          [ -f "${SRC}/dtbo.img" ] && cp "${SRC}/dtbo.img" kernel/ || true
          [ -d "${SRC}/dtb" ] && cp -r "${SRC}/dtb" kernel/ || true

          ZIP="../Docker-ready-kernel-${{ inputs.device }}-${{ inputs.branch }}.zip"
          zip -r9 "$ZIP" .
          echo "AK3 zip: $ZIP"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: kernel-build-${{ inputs.device }}-${{ inputs.branch }}
          path: |
            Docker-ready-kernel-${{ inputs.device }}-${{ inputs.branch }}.zip
            kernel_src/out/arch/arm64/boot/*
            kernel_src/out/.config

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          name: "Kernel Build - ${{ inputs.device }} (${{ inputs.branch }})"
          body: |
            ## Docker-ready kernel for ${{ inputs.device }}
            - Branch: ${{ inputs.branch }}
            - Includes AnyKernel3 zip for flashing
          files: |
            Docker-ready-kernel-${{ inputs.device }}-${{ inputs.branch }}.zip
            kernel_src/out/arch/arm64/boot/Image*
            kernel_src/out/.config
